
我们 这个 自定义 FFI , 相当于 一个 什么呢？


相当于
我们这个 想做的， 一个 patch,
这么一个语言， 想要接入 我们 OC 的 执行环境。



<hr>


我们 需要 往里面 ， 传递一个 什么命令。




<hr>


我们把 这个东西， 给规定出来。




<hr>



这样的话， 你就是在 执行这个 Patch
的 过程 当中，
你就可以 按照 这个命令，


去发 相应的 消息，
来 让 这个 context , 执行 你的 代码



<hr>


<hr>




# FFI， 讲完了。 开启 预编译





<hr>



<hr>


使用 JSPatch 的 过程当中，
你会发现


你会 用的 ， 非常的 不顺手，



<hr>


为什么 不顺手呢？



他就相当于， 把 JS 硬生生 转换成
相当于 OC 这种风格 的， 这么 一个东西。



<hr>



其间， 还做了一些 很多的 语言处理，


包括 他说的
源函数 的 这么一个处理，

包括 C 语言 函数
相当于 我们 Ruby 的 Method Mission 的 这么一个处理。
<hr>



其他 的 这么一个方式，


他 好像都是在 后端， 进行的。


<hr>


<hr>

我们 为了 加强 我们 Patch,  本身 具有的， 语言的 一个平滑性，

### JSCore 的 逼真度


会把 预编译 的 过程， 引出来。


<hr>

## 开始实践:

JSContext 注册 接口，

抽象出 三个层，



<hr>


<hr>


## define， 定义
你定义一些 什么 东西。

这都可以 自己去 定义的。
只要 抽象出 这一层， 就可以了。




define, 你往 OC 发消息。 你不需要 参数返回， 你可以用 define .



<hr>



## evaluate
去执行 一些 什么任务
你可能 需要 一个 返回值



<hr>



## Callback


当你 感觉 苹果 封装的 JSCore,
他有 一些 问题。




比如说， 你传递的 一些 函数 这样的 对象，
你 封装了 两层。
那就 你可能 获取 不到 这个对象了。

你可能 需要 Call back 这种 方式，
去在 那个 执行环境当中，
获取 前端的 function 内容。


JSCore 相关的，
一种 回调方式
来 取到 你在 当前 JS 环境 当中，的一个 function 值



<hr>




<hr>


## 指令 类型


我们 这个 patch ，是 干什么的？

* Patch 就是 执行 一些 Method 函数 的 一些 hook，

* 会修改 一些 property 的值了。
* 会 做一些 block 方面的改动了。

* 访问 父类 super


* 我们 可以 新增 函数，
method_create


对我们所使用的内容， 做一些 指令。

<hr>



通过 这些指令，
我们可以实现， 想要 patch 到的一些功能

<hr>


### 关键字 转换：
## 通过 预处理 ， 来搞。

<hr>



对于 OC 的 关键字，

OC 中的 self 关键字， 我们通常 用来代表 当前对象 的指针。


改 super 关键字， 为 oc_super.
因为 super 在 ES6 里面， 也是 关键字了。


original， 是 Patch 中特有的。调用 之前的 函数。
打补丁之前的 这个函数 的 调用。



我们 要完成， 对一些关键字的 处理。

<hr>


<hr>


### JS 写 高阶函数


对 高阶函数 做一个 平滑处理，
否则 可能写起来， 非常费劲。

<hr>

request 方法， 有三个参数

三个 function 类型的 参数。

第一个 function 函数， 接收两个参数。


第二个 参数 callback， 是我们在函数调用上下文中， 取的



第三个参数是， ES6 中， 使用的 箭头函数。


我们对这个 进行一些 支持

<hr>
<hr>




这么 一些操作，
也是 得 通过预处理的方式，
编译成，能够对接 OC 的 Block 指令的。


然后，才能 正常 完成工作。
