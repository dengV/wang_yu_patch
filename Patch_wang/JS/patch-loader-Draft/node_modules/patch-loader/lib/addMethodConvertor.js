var typeConvertor = require('./typeConvertor');
module.exports = function(babel){
const {types:t,template:tp} = babel;
  function convertJSType(typeAnnotation){
     if (t.isStringTypeAnnotation(typeAnnotation)){
         return typeConvertor('string');
     }else if(t.isNumberTypeAnnotation(typeAnnotation)){
         return typeConvertor('number');
     }else if(t.isBooleanTypeAnnotation(typeAnnotation)){
         return typeConvertor('boolean');
     }else if (t.isVoidTypeAnnotation(typeAnnotation)){
          return typeConvertor('void');
     }else if (t.isGenericTypeAnnotation(typeAnnotation)){
          return(typeConvertor(typeAnnotation.id.name));   
     }else if (t.isFunctionTypeAnnotation(typeAnnotation)){
          return(typeConvertor('function'));
     }else{
         if(typeAnnotation == null){
             throw "类型转换出错";
         }
         if(typeAnnotation.typeAnnotation != null)
          return  convertJSType(typeAnnotation.typeAnnotation);
         else
             throw "类型转换出错";
     }
  }

 const labdaDefineConvertorTemplate = tp(`function FUNCNAME(fn){ fn(SIGNATURE,SELNAME); return FUNCDECLARE;}`);
  function transferparam(param){ return param.replace(/_/g,'__')};
  const TypeFunctionConvertorVisitor = {
    FunctionDeclaration: function(path){
      let node = path.node;
      // 判断是否需要类型转换
       let initialType = t.isTypeAnnotation(node.returnType);
      let hasType = node.params.map( ele => t.isTypeAnnotation(ele.typeAnnotation)).reduce((a,b)=> a||b, initialType);
       if(!hasType) return;
        let argTypes = node.params.map(ele => convertJSType(ele.typeAnnotation));
        argTypes.unshift(initialType?convertJSType(node.returnType):typeConvertor('void'));
        let functionNameString = node.params.slice(0,node.params.length).map(ele => transferparam(ele.name)).reduce((a,b) => a+'_'+b);
        let functionSignString = argTypes.join(','); //得到了类型编码
        let functionSignNode = t.stringLiteral(functionSignString);
        let functionNameNode = t.identifier(node.id.name);
        let removeTypeParams = node.params.map(ele => {
             delete ele.typeAnnotation;
             return ele;
        });
        let functionExpNode = t.functionExpression(null,removeTypeParams,node.body);
        const caller = labdaDefineConvertorTemplate({FUNCNAME:functionNameNode,
            SIGNATURE:functionSignNode,FUNCDECLARE:functionExpNode,SELNAME:t.stringLiteral(functionNameString)}); 
        path.replaceWith(caller);   
    }
  }

  return {
    visitor:TypeFunctionConvertorVisitor
};
}