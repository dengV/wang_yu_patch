var typeConvertor = require('./typeConvertor');
module.exports = function(babel){
const {types:t,template:tp} = babel;

  function convertJSType(typeAnnotation){
     if (t.isStringTypeAnnotation(typeAnnotation)){
         return typeConvertor('string');
     }else if(t.isNumberTypeAnnotation(typeAnnotation)){
         return typeConvertor('number');
     }else if(t.isBooleanTypeAnnotation(typeAnnotation)){
         return typeConvertor('boolean');
     }else if (t.isVoidTypeAnnotation(typeAnnotation)){
          return typeConvertor('void');
     }else if (t.isGenericTypeAnnotation(typeAnnotation)){
          return(typeConvertor(typeAnnotation.id.name));   
     }else if (t.isFunctionTypeAnnotation(typeAnnotation)){
          return(typeConvertor('function'));
     }else{
         if(typeAnnotation == null){
             throw "类型转换出错";
         }
         if(typeAnnotation.typeAnnotation != null)
          return  convertJSType(typeAnnotation.typeAnnotation);
         else
             throw "类型转换出错";
     }
  }

const lambdaDefineTemplate = tp(`lambdaDefine(SIGNATURE,CALLBACK)`);

  const BlockTypeConvertVisitor = {
    CallExpression :function(path){
     let node = path.node; // 获得当前的node节点
     if (t.isIdentifier(node.callee) && node.callee.name ==='lambdaDefine'){
         return;
     }
      let args = node.arguments;
     for( let i = 0; i < args.length;i++){
       // 每个不同的args 参数是FunctionExpression
       let arg = args[i];
       if(t.isFunctionExpression(arg)){
          //函数表达式，提取函数类型
          let functionSign = [];
          let params = arg.params;
          for(param of params){
             if(t.isIdentifier(param)){
                 let typeAnnotation = param.typeAnnotation;
                  if(typeAnnotation != null){
                     functionSign.push(convertJSType(typeAnnotation));
                  }
             } 
          }
          let retType = arg.returnType;
          if(t.isTypeAnnotation(retType)){
            functionSign.unshift(convertJSType(retType.typeAnnotation)) 
          }else{
            functionSign.unshift(typeConvertor('void'));
          }
           let functionSignString = functionSign.join(',');
            let functionSignNode = t.stringLiteral(functionSignString);
            const caller = lambdaDefineTemplate({SIGNATURE:functionSignNode,CALLBACK:arg});
            args[i] = caller.expression;
         
       } else if (t.isTypeCastExpression(arg)){
         // 类型转换的表达式
           let funcTypeAnnotation = arg.typeAnnotation.typeAnnotation;
           if(t.isFunctionTypeAnnotation(funcTypeAnnotation)){
              let functionSign = [];
              let params = funcTypeAnnotation.params; 
              for (param of params){
                  if(t.isFunctionTypeParam(param)){
                      functionSign.push(convertJSType( param.typeAnnotation));
                  }
              }
              //处理return type
                let retType = funcTypeAnnotation.returnType;
                functionSign.unshift(convertJSType(retType));              
                let functionSignString = functionSign.join(',');
                let functionSignNode = t.stringLiteral(functionSignString);
                const caller = lambdaDefineTemplate({SIGNATURE:functionSignNode,CALLBACK:arg});
                args[i] = caller.expression; 
           }
       }else if(t.isArrowFunctionExpression(arg)){
        // 表示箭头函数
         let functionSign = []; 
         let params = arg.params;
            for(param of params){
             if(t.isIdentifier(param)){
                 let typeAnnotation = param.typeAnnotation;
                  if(typeAnnotation != null){
                     functionSign.push(convertJSType(typeAnnotation));
                  }
             } 
          }
          let retType = arg.returnType;
          if(t.isTypeAnnotation(retType)){
            functionSign.unshift(convertJSType(retType.typeAnnotation)) 
          }else{
            functionSign.unshift(typeConvertor('void'));
          }
           let functionSignString = functionSign.join(',');
           let functionSignNode = t.stringLiteral(functionSignString);
           const caller = lambdaDefineTemplate({SIGNATURE:functionSignNode,CALLBACK:arg});
           args[i] = caller.expression;

       }
     } 
    },
    ReturnStatement :function(path){
      let node = path.node;
      let retArgument = node.argument;// 获取到返回值的argument
      
      if(t.isArrowFunctionExpression(retArgument)|| t.isFunctionExpression(retArgument)){
        let functionSign = retArgument.params.filter(ele => t.isIdentifier(ele) && ele.typeAnnotation).map(ele => convertJSType(ele.typeAnnotation));
        if(t.isTypeAnnotation(retArgument.returnType)){
            functionSign.unshift(convertJSType(retArgument.returnType.typeAnnotation)); 
        }else{
           functionSign.length > 0 ? functionSign.unshift(typeConvertor('void')):undefined;
        }
         if(functionSign.length == 0) return;
         let functionSignString = functionSign.join(',');
         let functionSignNode = t.stringLiteral(functionSignString); 
         const caller = lambdaDefineTemplate({SIGNATURE:functionSignNode,CALLBACK:retArgument});
        node.argument = caller.expression;
      }else if(t.isTypeCastExpression(retArgument)){
       //是类型转换函数
        let funcTypeAnnotation = retArgument.typeAnnotation.typeAnnotation; 
         if(t.isFunctionTypeAnnotation(funcTypeAnnotation)){
             let functionSign = funcTypeAnnotation.params.filter(ele => t.isFunctionTypeParam(ele) && ele.typeAnnotation).map(ele => convertJSType(ele.typeAnnotation)); 
             let retType = funcTypeAnnotation.returnType;
             functionSign.unshift(convertJSType(retType));    
              let functionSignString = functionSign.join(',');
         let functionSignNode = t.stringLiteral(functionSignString); 
         const caller = lambdaDefineTemplate({SIGNATURE:functionSignNode,CALLBACK:retArgument.expression});
         node.argument = caller.expression;
         }
     }
   }
  }
  
   // 用来对函数的声明判断是有类型的进行封装与替换
  

return {
    visitor:BlockTypeConvertVisitor
};


}