module.exports = function(babel){
   const {types:t,template:tp} = babel;
   var method_name = '__methodMissing';
// 替换this 的子函数
  const RepaceSlfIdSubVisitor = {
    Identifier(path) {
    if (path.node.name == this.slf) {
      path.replaceWith(t.thisExpression());
    }
  }
   }

    // 支持oc的super 关键字
 const OCSuperTemplate = tp(`new Super(INSTANCE)`); // OCSuper对象模板
 const OCSuperAdditionVisitor = {
      Identifier(path) {
        let token = this._super;
        let parentPath = path.parentPath;
        let node = path.node;
        if (node.name == token){
         if(!parentPath.isCallExpression()){
           path.replaceWith(t.callExpression(t.identifier(token),[]));
        }
        }  
      },
      CallExpression(path){
        let token = this._super;
        let callee = path.node.callee;
        let parentPath = path.parentPath; //根据parentPath 判断
        if (t.isIdentifier(callee)) {
           if(callee.name == token){
            // 父路径是meberexpression;
             if(parentPath.isMemberExpression()) {
              // 直接将callExpression 进行替换
              const caller = OCSuperTemplate({INSTANCE:t.thisExpression()});     
              parentPath.node.object = caller.expression; 
             }else{
             const nearestFuncPath = path.getFunctionParent(); //获取到function的表达式
             const nearestFuncNode = nearestFuncPath.node; //获得参数
             const parentNode = nearestFuncPath.parentPath.node; //获得子节点
             if (t.isObjectProperty(parentNode)) {
             const funcName = parentNode.key.name;
             const args = nearestFuncNode.params.map(node => t.identifier(node.name));
             const caller = OCSuperTemplate({INSTANCE:t.thisExpression()});
             path.node.callee =  t.memberExpression(caller.expression,t.identifier(funcName));
             path.node.arguments = args;
             }else{
              const funcName = nearestFuncNode.id.name;
              const args = nearestFuncNode.params.map(node => t.identifier(node.name));
              const caller = OCSuperTemplate({INSTANCE:t.thisExpression()});
              path.node.callee =  t.memberExpression(caller.expression,t.identifier(funcName));
              path.node.arguments = args;
            }
             }
           }
        }
      }
 } 




// 对original 语句的支持
 const orignalToken = 'original';
 const originalTokenReg = /^(?:original)/;
 //检测是否original
 function isOriginalToken(token){
   return token.match(originalTokenReg) && true;
 }
 //对token 进行处理
 function replacePrifix(token, prefix){
  if(token.length > 0) {
   let replacingToken = token.replace(originalTokenReg,"");
   if (replacingToken.length == 0) {return prefix};
   let replacedToken = replacingToken[0].toLowerCase() + replacingToken.substring(1,replacingToken.length);
    return prefix + replacedToken;
  }else{
    return null;
  }
 }
 const OriginalAdditionVisitor = {
   CallExpression(path){
     let callee = path.node.callee;
     let _orginalPrefix = this._orginalPrefix;
     if(t.isIdentifier(callee)) {
       // callee 是一个identfier
        if(isOriginalToken(callee.name)){
          let replacedName = replacePrifix(callee.name,_orginalPrefix);
          const nearestFuncPath = path.getFunctionParent(); //获取到function的表达式
          const nearestFuncNode = nearestFuncPath.node; //获得参数
          const parentNode = nearestFuncPath.parentPath.node; //获得子节点
          if (replacedName == _orginalPrefix) {
            if (t.isObjectProperty(parentNode)) {
               const funcName = _orginalPrefix + parentNode.key.name; // original m名字
               const args = nearestFuncNode.params.map(node => t.identifier(node.name));
               //把callee 替换一下
               path.node.callee = t.memberExpression(t.thisExpression(),t.identifier(funcName));
               path.node.arguments = args;
            } else{
              // 找到函数名字
              const funcName = nearestFuncNode.id.name;
              const args = nearestFuncNode.params.map(node => t.identifier(node.name));
              path.node.callee = t.memberExpression(t.thisExpression(),t.identifier(funcName));
              path.node.arguments = args;
            }
          }else{
            // 增加一个this的调用
            const funcName = replacedName;
            path.node.callee = t.memberExpression(t.thisExpression(),t.identifier(funcName));
          }
        }
     }else if (t.isMemberExpression(callee)){
            if (isOriginalToken(callee.property.name)) { 
              let replacedName = replacePrifix(callee.property.name,_orginalPrefix);
              if(replacedName == _orginalPrefix) {
                  const nearestFuncPath = path.getFunctionParent(); //获取到function的表达式
                  const nearestFuncNode = nearestFuncPath.node; //获得参数
                  const parentNode = nearestFuncPath.parentPath.node; //获得子节点
                  if (t.isObjectProperty(parentNode)) {
                     const funcName = _orginalPrefix + parentNode.key.name; // original m名字
                     const args = nearestFuncNode.params.map(node => t.identifier(node.name));
                     path.node.callee = t.memberExpression(t.thisExpression(),t.identifier(funcName));
                     path.node.arguments = args;
                  } else{
                    // 找到函数名字
                     const funcName = nearestFuncNode.id.name;
                     const args = nearestFuncNode.params.map(node => t.identifier(node.name));
                     path.node.callee = t.memberExpression(t.thisExpression(),t.identifier(funcName));
                     path.node.arguments = args;
                  }
              }else{
                 callee.property = t.identifier(replacedName);
              }
            }
     }
   }
 }
// 对关键字的支持
  const ReplaceKeywordsVisitor = {
   Function(path){
     const slf = "self";
     path.traverse(RepaceSlfIdSubVisitor,{slf});
     const _super = "oc_super";
     path.traverse(OCSuperAdditionVisitor,{_super});
     const _orginalPrefix = "__lufix";
     path.traverse(OriginalAdditionVisitor,{_orginalPrefix});
   }
  }
  
// 对set 和 getter 方法的封装
 const ReplaceGetterSetterVisitor = {
  MemberExpression(path){
   const node = path.node;
   let parentPath = path.parentPath;
   if(!parentPath.isAssignmentExpression()|| parentPath.node.left != node){
     // 不是调用的callee
     if(parentPath.node.callee != node){
      const OCgetterTemplate = tp(`INSATNCE.oc_get_prop(VALUE)`); // OCSuper对象模板
       let property;
       if(t.isIdentifier(node.property)) {
          property = t.stringLiteral(node.property.name); // 获得属性的字符串表示
       }else{
         property = node.property;
       }
      const caller = OCgetterTemplate({VALUE:property,INSATNCE:node.object});  
      path.replaceWith(caller.expression);
   }
  }else{
    // 表示赋值操作 将赋值操作替换成调用
       if(parentPath.isAssignmentExpression){
          const OCsetterTemplate = tp(`INSATNCE.oc_set_prop(PROPERTY,VALUE)`); // OCSuper对象模板
          let property;
        if(t.isIdentifier(node.property)) {
          property = t.stringLiteral(node.property.name); // 获得属性的字符串表示
       }else{
         property = node.property;
       }
       const caller = OCsetterTemplate({PROPERTY:property,INSATNCE:node.object, VALUE: parentPath.node.right});
       parentPath.replaceWith(caller.expression);
       }
   }
 
  }


 }

  const ReplaceMethodMissingVistor = {
        CallExpression: function(path){
         var callee  = path.node.callee;
         var callee_name;
         var callee_obj;
         if (t.isMemberExpression(callee)){
            if (t.isIdentifier(callee.property) ){
             callee_name =  t.stringLiteral(callee.property.name);
            }
           callee_obj = callee.object;
           var args = path.node.arguments;
           if (callee_name != null){
             args.unshift(callee_name);
           }
           path.node.callee =  t.memberExpression(callee_obj, t.identifier(method_name))
         }

      }
  }


    return {
    visitor: Object.assign(ReplaceMethodMissingVistor,ReplaceKeywordsVisitor,ReplaceGetterSetterVisitor)
    };
};
